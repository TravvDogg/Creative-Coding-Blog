---
title: "Week 9b: Graphical Programming Languages"
published_at: 2025-05-13
snippet: I follow a tutorial to learn PureData
disable_html_sanitization: true
allow_math: true
---
# Making and Seeing Sound in Pure Data (tutorial)
https://www.youtube.com/watch?v=YnQoBLL0TxM
<div style="position: relative; width: 100%; padding-top: 56.25%;">
  <iframe
    id="pd-tutorial"
	src="https://www.youtube.com/embed/YnQoBLL0TxM" 
    title="2. Making and Seeing Sound in Pure Data"
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen>
  </iframe>
</div>

I followed this tutorial to learn about pure data. Andrew was quite good at describing what was going on, and there was no point that i was stuck or didn't know where i was going.

## Screenshot
![pd-example](Wk-9B/puredata-example.png)


why you are interested in this GPL
how you might use this GPL in your own creative practice
the strengths & weaknesses of this GPL vs other GPLs
the strengths & weaknesses of GPLs in general, vs text based scripting languages

# Visual Programming in PureData
## Why Puredata?
it looks the most 'clean' and elegant, compared to other options

## How might i use it in my creative practice
It could be a potential tool to use with live coding, or rudimentary AV simulation

## Strengths and Weaknesses of PD
it's lack of a formal GUI gives a differently shaped skill curve than something with an intuitive UI, however once you have it learned, it can be quite fast and efficient to work with. I find it best compared to coding in VIM vs a graphical programming interface like VSCode

## Strengths and Weaknesses of GPL's compared to text based scripting

There are inherently harder or impossible things to do in Graphical programming languages that are relatively easy or rudimentary in text based languages, like recursion. They can also be slower as projects get larger, and it can be harder to assess the logical flow of code without the use of variables and as codebases get larger, disambiguation leads to impossible to debug code.